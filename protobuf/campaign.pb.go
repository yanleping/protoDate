// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: campaign.proto

/*
	Package protobuf is a generated protocol buffer package.

	It is generated from these files:
		campaign.proto

	It has these top-level messages:
		Campaign
		MapValue
		AdvImp
		LoopBack
		AppPostList
		EndCard
		VideoTemplateUrlItem
		EndCardUrls
		ConfigVBA
		TCQF
		BtV4
		BtClass
		SubInfo
		DspSubInfo
*/
package protobuf

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Campaign struct {
	CampaignId         int64                `protobuf:"varint,1,opt,name=campaignId,proto3" json:"campaignId,omitempty"`
	AdvertiserId       int32                `protobuf:"varint,2,opt,name=advertiserId,proto3" json:"advertiserId,omitempty"`
	TrackingUrl        string               `protobuf:"bytes,3,opt,name=trackingUrl,proto3" json:"trackingUrl,omitempty"`
	DirectUrl          string               `protobuf:"bytes,4,opt,name=directUrl,proto3" json:"directUrl,omitempty"`
	Price              float64              `protobuf:"fixed64,5,opt,name=price,proto3" json:"price,omitempty"`
	OriPrice           float64              `protobuf:"fixed64,6,opt,name=oriPrice,proto3" json:"oriPrice,omitempty"`
	Status             int32                `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
	Network            int32                `protobuf:"varint,8,opt,name=network,proto3" json:"network,omitempty"`
	PreviewUrl         string               `protobuf:"bytes,9,opt,name=previewUrl,proto3" json:"previewUrl,omitempty"`
	PackageName        string               `protobuf:"bytes,10,opt,name=packageName,proto3" json:"packageName,omitempty"`
	CampaignType       int32                `protobuf:"varint,11,opt,name=campaignType,proto3" json:"campaignType,omitempty"`
	CType              int32                `protobuf:"varint,12,opt,name=cType,proto3" json:"cType,omitempty"`
	AppSize            string               `protobuf:"bytes,13,opt,name=appSize,proto3" json:"appSize,omitempty"`
	Tag                int32                `protobuf:"varint,14,opt,name=tag,proto3" json:"tag,omitempty"`
	AdSourceId         int32                `protobuf:"varint,15,opt,name=adSourceId,proto3" json:"adSourceId,omitempty"`
	PublisherId        int64                `protobuf:"varint,16,opt,name=publisherId,proto3" json:"publisherId,omitempty"`
	PreClickCacheTime  int32                `protobuf:"varint,17,opt,name=preClickCacheTime,proto3" json:"preClickCacheTime,omitempty"`
	FrequencyCap       int32                `protobuf:"varint,18,opt,name=frequencyCap,proto3" json:"frequencyCap,omitempty"`
	DirectPackageName  string               `protobuf:"bytes,19,opt,name=directPackageName,proto3" json:"directPackageName,omitempty"`
	SdkPackageName     string               `protobuf:"bytes,20,opt,name=sdkPackageName,proto3" json:"sdkPackageName,omitempty"`
	JumpType           int32                `protobuf:"varint,21,opt,name=jumpType,proto3" json:"jumpType,omitempty"`
	VbaConnecting      int32                `protobuf:"varint,22,opt,name=vbaConnecting,proto3" json:"vbaConnecting,omitempty"`
	VbaTrackingLink    string               `protobuf:"bytes,23,opt,name=vbaTrackingLink,proto3" json:"vbaTrackingLink,omitempty"`
	RetargetingDevice  int32                `protobuf:"varint,24,opt,name=retargetingDevice,proto3" json:"retargetingDevice,omitempty"`
	SendDeviceidRate   int32                `protobuf:"varint,25,opt,name=sendDeviceidRate,proto3" json:"sendDeviceidRate,omitempty"`
	BelongType         int32                `protobuf:"varint,26,opt,name=belongType,proto3" json:"belongType,omitempty"`
	OpenType           int32                `protobuf:"varint,27,opt,name=openType,proto3" json:"openType,omitempty"`
	IsCampaignCreative int32                `protobuf:"varint,28,opt,name=isCampaignCreative,proto3" json:"isCampaignCreative,omitempty"`
	CostType           int32                `protobuf:"varint,29,opt,name=costType,proto3" json:"costType,omitempty"`
	Source             int32                `protobuf:"varint,30,opt,name=source,proto3" json:"source,omitempty"`
	ChnId              int32                `protobuf:"varint,31,opt,name=chnId,proto3" json:"chnId,omitempty"`
	ThirdParty         string               `protobuf:"bytes,32,opt,name=thirdParty,proto3" json:"thirdParty,omitempty"`
	AdUrlList          []string             `protobuf:"bytes,33,rep,name=adUrlList" json:"adUrlList,omitempty"`
	SubCategoryName    []string             `protobuf:"bytes,34,rep,name=subCategoryName" json:"subCategoryName,omitempty"`
	JumpTypeConfig     map[string]int32     `protobuf:"bytes,35,rep,name=jumpTypeConfig" json:"jumpTypeConfig,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	BlackSubIdListV2   map[string]*MapValue `protobuf:"bytes,36,rep,name=blackSubIdListV2" json:"blackSubIdListV2,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	AdvImp             []*AdvImp            `protobuf:"bytes,37,rep,name=advImp" json:"advImp,omitempty"`
	LoopBack           *LoopBack            `protobuf:"bytes,38,opt,name=loopBack" json:"loopBack,omitempty"`
	AppPostList        *AppPostList         `protobuf:"bytes,39,opt,name=appPostList" json:"appPostList,omitempty"`
	ConfigVBA          *ConfigVBA           `protobuf:"bytes,40,opt,name=configVBA" json:"configVBA,omitempty"`
	Tcqf               *TCQF                `protobuf:"bytes,41,opt,name=tcqf" json:"tcqf,omitempty"`
	BtV4               *BtV4                `protobuf:"bytes,42,opt,name=btV4" json:"btV4,omitempty"`
	EndCard            map[string]*EndCard  `protobuf:"bytes,43,rep,name=endCard" json:"endCard,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Campaign) Reset()                    { *m = Campaign{} }
func (m *Campaign) String() string            { return proto.CompactTextString(m) }
func (*Campaign) ProtoMessage()               {}
func (*Campaign) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{0} }

func (m *Campaign) GetCampaignId() int64 {
	if m != nil {
		return m.CampaignId
	}
	return 0
}

func (m *Campaign) GetAdvertiserId() int32 {
	if m != nil {
		return m.AdvertiserId
	}
	return 0
}

func (m *Campaign) GetTrackingUrl() string {
	if m != nil {
		return m.TrackingUrl
	}
	return ""
}

func (m *Campaign) GetDirectUrl() string {
	if m != nil {
		return m.DirectUrl
	}
	return ""
}

func (m *Campaign) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Campaign) GetOriPrice() float64 {
	if m != nil {
		return m.OriPrice
	}
	return 0
}

func (m *Campaign) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Campaign) GetNetwork() int32 {
	if m != nil {
		return m.Network
	}
	return 0
}

func (m *Campaign) GetPreviewUrl() string {
	if m != nil {
		return m.PreviewUrl
	}
	return ""
}

func (m *Campaign) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *Campaign) GetCampaignType() int32 {
	if m != nil {
		return m.CampaignType
	}
	return 0
}

func (m *Campaign) GetCType() int32 {
	if m != nil {
		return m.CType
	}
	return 0
}

func (m *Campaign) GetAppSize() string {
	if m != nil {
		return m.AppSize
	}
	return ""
}

func (m *Campaign) GetTag() int32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *Campaign) GetAdSourceId() int32 {
	if m != nil {
		return m.AdSourceId
	}
	return 0
}

func (m *Campaign) GetPublisherId() int64 {
	if m != nil {
		return m.PublisherId
	}
	return 0
}

func (m *Campaign) GetPreClickCacheTime() int32 {
	if m != nil {
		return m.PreClickCacheTime
	}
	return 0
}

func (m *Campaign) GetFrequencyCap() int32 {
	if m != nil {
		return m.FrequencyCap
	}
	return 0
}

func (m *Campaign) GetDirectPackageName() string {
	if m != nil {
		return m.DirectPackageName
	}
	return ""
}

func (m *Campaign) GetSdkPackageName() string {
	if m != nil {
		return m.SdkPackageName
	}
	return ""
}

func (m *Campaign) GetJumpType() int32 {
	if m != nil {
		return m.JumpType
	}
	return 0
}

func (m *Campaign) GetVbaConnecting() int32 {
	if m != nil {
		return m.VbaConnecting
	}
	return 0
}

func (m *Campaign) GetVbaTrackingLink() string {
	if m != nil {
		return m.VbaTrackingLink
	}
	return ""
}

func (m *Campaign) GetRetargetingDevice() int32 {
	if m != nil {
		return m.RetargetingDevice
	}
	return 0
}

func (m *Campaign) GetSendDeviceidRate() int32 {
	if m != nil {
		return m.SendDeviceidRate
	}
	return 0
}

func (m *Campaign) GetBelongType() int32 {
	if m != nil {
		return m.BelongType
	}
	return 0
}

func (m *Campaign) GetOpenType() int32 {
	if m != nil {
		return m.OpenType
	}
	return 0
}

func (m *Campaign) GetIsCampaignCreative() int32 {
	if m != nil {
		return m.IsCampaignCreative
	}
	return 0
}

func (m *Campaign) GetCostType() int32 {
	if m != nil {
		return m.CostType
	}
	return 0
}

func (m *Campaign) GetSource() int32 {
	if m != nil {
		return m.Source
	}
	return 0
}

func (m *Campaign) GetChnId() int32 {
	if m != nil {
		return m.ChnId
	}
	return 0
}

func (m *Campaign) GetThirdParty() string {
	if m != nil {
		return m.ThirdParty
	}
	return ""
}

func (m *Campaign) GetAdUrlList() []string {
	if m != nil {
		return m.AdUrlList
	}
	return nil
}

func (m *Campaign) GetSubCategoryName() []string {
	if m != nil {
		return m.SubCategoryName
	}
	return nil
}

func (m *Campaign) GetJumpTypeConfig() map[string]int32 {
	if m != nil {
		return m.JumpTypeConfig
	}
	return nil
}

func (m *Campaign) GetBlackSubIdListV2() map[string]*MapValue {
	if m != nil {
		return m.BlackSubIdListV2
	}
	return nil
}

func (m *Campaign) GetAdvImp() []*AdvImp {
	if m != nil {
		return m.AdvImp
	}
	return nil
}

func (m *Campaign) GetLoopBack() *LoopBack {
	if m != nil {
		return m.LoopBack
	}
	return nil
}

func (m *Campaign) GetAppPostList() *AppPostList {
	if m != nil {
		return m.AppPostList
	}
	return nil
}

func (m *Campaign) GetConfigVBA() *ConfigVBA {
	if m != nil {
		return m.ConfigVBA
	}
	return nil
}

func (m *Campaign) GetTcqf() *TCQF {
	if m != nil {
		return m.Tcqf
	}
	return nil
}

func (m *Campaign) GetBtV4() *BtV4 {
	if m != nil {
		return m.BtV4
	}
	return nil
}

func (m *Campaign) GetEndCard() map[string]*EndCard {
	if m != nil {
		return m.EndCard
	}
	return nil
}

type MapValue struct {
	MapValue map[string]string `protobuf:"bytes,1,rep,name=mapValue" json:"mapValue,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MapValue) Reset()                    { *m = MapValue{} }
func (m *MapValue) String() string            { return proto.CompactTextString(m) }
func (*MapValue) ProtoMessage()               {}
func (*MapValue) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{1} }

func (m *MapValue) GetMapValue() map[string]string {
	if m != nil {
		return m.MapValue
	}
	return nil
}

type AdvImp struct {
	Sec int32  `protobuf:"varint,1,opt,name=sec,proto3" json:"sec,omitempty"`
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *AdvImp) Reset()                    { *m = AdvImp{} }
func (m *AdvImp) String() string            { return proto.CompactTextString(m) }
func (*AdvImp) ProtoMessage()               {}
func (*AdvImp) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{2} }

func (m *AdvImp) GetSec() int32 {
	if m != nil {
		return m.Sec
	}
	return 0
}

func (m *AdvImp) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type LoopBack struct {
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	Key    string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value  string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Rate   int32  `protobuf:"varint,4,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *LoopBack) Reset()                    { *m = LoopBack{} }
func (m *LoopBack) String() string            { return proto.CompactTextString(m) }
func (*LoopBack) ProtoMessage()               {}
func (*LoopBack) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{3} }

func (m *LoopBack) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *LoopBack) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LoopBack) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *LoopBack) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type AppPostList struct {
	Include []string `protobuf:"bytes,1,rep,name=include" json:"include,omitempty"`
	Exclude []string `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
}

func (m *AppPostList) Reset()                    { *m = AppPostList{} }
func (m *AppPostList) String() string            { return proto.CompactTextString(m) }
func (*AppPostList) ProtoMessage()               {}
func (*AppPostList) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{4} }

func (m *AppPostList) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *AppPostList) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

type EndCard struct {
	Urls             []*EndCardUrls          `protobuf:"bytes,1,rep,name=urls" json:"urls,omitempty"`
	Status           int32                   `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	Orientation      int32                   `protobuf:"varint,3,opt,name=orientation,proto3" json:"orientation,omitempty"`
	VideoTemplateUrl []*VideoTemplateUrlItem `protobuf:"bytes,4,rep,name=videoTemplateUrl" json:"videoTemplateUrl,omitempty"`
	EndcardProtocal  int32                   `protobuf:"varint,5,opt,name=endcardProtocal,proto3" json:"endcardProtocal,omitempty"`
	EndcardRate      map[int32]int32         `protobuf:"bytes,6,rep,name=endcardRate" json:"endcardRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *EndCard) Reset()                    { *m = EndCard{} }
func (m *EndCard) String() string            { return proto.CompactTextString(m) }
func (*EndCard) ProtoMessage()               {}
func (*EndCard) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{5} }

func (m *EndCard) GetUrls() []*EndCardUrls {
	if m != nil {
		return m.Urls
	}
	return nil
}

func (m *EndCard) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *EndCard) GetOrientation() int32 {
	if m != nil {
		return m.Orientation
	}
	return 0
}

func (m *EndCard) GetVideoTemplateUrl() []*VideoTemplateUrlItem {
	if m != nil {
		return m.VideoTemplateUrl
	}
	return nil
}

func (m *EndCard) GetEndcardProtocal() int32 {
	if m != nil {
		return m.EndcardProtocal
	}
	return 0
}

func (m *EndCard) GetEndcardRate() map[int32]int32 {
	if m != nil {
		return m.EndcardRate
	}
	return nil
}

type VideoTemplateUrlItem struct {
	Id           int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Url          string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	UrlZip       string `protobuf:"bytes,3,opt,name=urlZip,proto3" json:"urlZip,omitempty"`
	Weight       int32  `protobuf:"varint,4,opt,name=weight,proto3" json:"weight,omitempty"`
	PausedUrl    string `protobuf:"bytes,5,opt,name=pausedUrl,proto3" json:"pausedUrl,omitempty"`
	PausedUrlZip string `protobuf:"bytes,6,opt,name=pausedUrlZip,proto3" json:"pausedUrlZip,omitempty"`
}

func (m *VideoTemplateUrlItem) Reset()                    { *m = VideoTemplateUrlItem{} }
func (m *VideoTemplateUrlItem) String() string            { return proto.CompactTextString(m) }
func (*VideoTemplateUrlItem) ProtoMessage()               {}
func (*VideoTemplateUrlItem) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{6} }

func (m *VideoTemplateUrlItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *VideoTemplateUrlItem) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *VideoTemplateUrlItem) GetUrlZip() string {
	if m != nil {
		return m.UrlZip
	}
	return ""
}

func (m *VideoTemplateUrlItem) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *VideoTemplateUrlItem) GetPausedUrl() string {
	if m != nil {
		return m.PausedUrl
	}
	return ""
}

func (m *VideoTemplateUrlItem) GetPausedUrlZip() string {
	if m != nil {
		return m.PausedUrlZip
	}
	return ""
}

type EndCardUrls struct {
	Id     int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Url    string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Weight int32  `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	UrlV2  string `protobuf:"bytes,4,opt,name=urlV2,proto3" json:"urlV2,omitempty"`
}

func (m *EndCardUrls) Reset()                    { *m = EndCardUrls{} }
func (m *EndCardUrls) String() string            { return proto.CompactTextString(m) }
func (*EndCardUrls) ProtoMessage()               {}
func (*EndCardUrls) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{7} }

func (m *EndCardUrls) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EndCardUrls) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *EndCardUrls) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *EndCardUrls) GetUrlV2() string {
	if m != nil {
		return m.UrlV2
	}
	return ""
}

type ConfigVBA struct {
	UseVBA       int32 `protobuf:"varint,1,opt,name=useVBA,proto3" json:"useVBA,omitempty"`
	FrequencyCap int32 `protobuf:"varint,2,opt,name=frequencyCap,proto3" json:"frequencyCap,omitempty"`
	Status       int32 `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ConfigVBA) Reset()                    { *m = ConfigVBA{} }
func (m *ConfigVBA) String() string            { return proto.CompactTextString(m) }
func (*ConfigVBA) ProtoMessage()               {}
func (*ConfigVBA) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{8} }

func (m *ConfigVBA) GetUseVBA() int32 {
	if m != nil {
		return m.UseVBA
	}
	return 0
}

func (m *ConfigVBA) GetFrequencyCap() int32 {
	if m != nil {
		return m.FrequencyCap
	}
	return 0
}

func (m *ConfigVBA) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type TCQF struct {
	SubIds map[string]*SubInfo `protobuf:"bytes,1,rep,name=subIds" json:"subIds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TCQF) Reset()                    { *m = TCQF{} }
func (m *TCQF) String() string            { return proto.CompactTextString(m) }
func (*TCQF) ProtoMessage()               {}
func (*TCQF) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{9} }

func (m *TCQF) GetSubIds() map[string]*SubInfo {
	if m != nil {
		return m.SubIds
	}
	return nil
}

type BtV4 struct {
	SubIds  map[string]*SubInfo `protobuf:"bytes,1,rep,name=subIds" json:"subIds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	BtClass map[string]*BtClass `protobuf:"bytes,2,rep,name=btClass" json:"btClass,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BtV4) Reset()                    { *m = BtV4{} }
func (m *BtV4) String() string            { return proto.CompactTextString(m) }
func (*BtV4) ProtoMessage()               {}
func (*BtV4) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{10} }

func (m *BtV4) GetSubIds() map[string]*SubInfo {
	if m != nil {
		return m.SubIds
	}
	return nil
}

func (m *BtV4) GetBtClass() map[string]*BtClass {
	if m != nil {
		return m.BtClass
	}
	return nil
}

type BtClass struct {
	Percent   float64 `protobuf:"fixed64,1,opt,name=percent,proto3" json:"percent,omitempty"`
	CapMargin int32   `protobuf:"varint,2,opt,name=capMargin,proto3" json:"capMargin,omitempty"`
	Status    int32   `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *BtClass) Reset()                    { *m = BtClass{} }
func (m *BtClass) String() string            { return proto.CompactTextString(m) }
func (*BtClass) ProtoMessage()               {}
func (*BtClass) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{11} }

func (m *BtClass) GetPercent() float64 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *BtClass) GetCapMargin() int32 {
	if m != nil {
		return m.CapMargin
	}
	return 0
}

func (m *BtClass) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type SubInfo struct {
	Rate        int32                  `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	PackageName string                 `protobuf:"bytes,2,opt,name=packageName,proto3" json:"packageName,omitempty"`
	DspSubInfo  map[string]*DspSubInfo `protobuf:"bytes,3,rep,name=dspSubInfo" json:"dspSubInfo,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SubInfo) Reset()                    { *m = SubInfo{} }
func (m *SubInfo) String() string            { return proto.CompactTextString(m) }
func (*SubInfo) ProtoMessage()               {}
func (*SubInfo) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{12} }

func (m *SubInfo) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

func (m *SubInfo) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func (m *SubInfo) GetDspSubInfo() map[string]*DspSubInfo {
	if m != nil {
		return m.DspSubInfo
	}
	return nil
}

type DspSubInfo struct {
	Rate        int32  `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	PackageName string `protobuf:"bytes,2,opt,name=packageName,proto3" json:"packageName,omitempty"`
}

func (m *DspSubInfo) Reset()                    { *m = DspSubInfo{} }
func (m *DspSubInfo) String() string            { return proto.CompactTextString(m) }
func (*DspSubInfo) ProtoMessage()               {}
func (*DspSubInfo) Descriptor() ([]byte, []int) { return fileDescriptorCampaign, []int{13} }

func (m *DspSubInfo) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

func (m *DspSubInfo) GetPackageName() string {
	if m != nil {
		return m.PackageName
	}
	return ""
}

func init() {
	proto.RegisterType((*Campaign)(nil), "protobuf.Campaign")
	proto.RegisterType((*MapValue)(nil), "protobuf.MapValue")
	proto.RegisterType((*AdvImp)(nil), "protobuf.AdvImp")
	proto.RegisterType((*LoopBack)(nil), "protobuf.LoopBack")
	proto.RegisterType((*AppPostList)(nil), "protobuf.AppPostList")
	proto.RegisterType((*EndCard)(nil), "protobuf.EndCard")
	proto.RegisterType((*VideoTemplateUrlItem)(nil), "protobuf.VideoTemplateUrlItem")
	proto.RegisterType((*EndCardUrls)(nil), "protobuf.EndCardUrls")
	proto.RegisterType((*ConfigVBA)(nil), "protobuf.ConfigVBA")
	proto.RegisterType((*TCQF)(nil), "protobuf.TCQF")
	proto.RegisterType((*BtV4)(nil), "protobuf.BtV4")
	proto.RegisterType((*BtClass)(nil), "protobuf.BtClass")
	proto.RegisterType((*SubInfo)(nil), "protobuf.SubInfo")
	proto.RegisterType((*DspSubInfo)(nil), "protobuf.DspSubInfo")
}
func (m *Campaign) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Campaign) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CampaignId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.CampaignId))
	}
	if m.AdvertiserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.AdvertiserId))
	}
	if len(m.TrackingUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.TrackingUrl)))
		i += copy(dAtA[i:], m.TrackingUrl)
	}
	if len(m.DirectUrl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.DirectUrl)))
		i += copy(dAtA[i:], m.DirectUrl)
	}
	if m.Price != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i += 8
	}
	if m.OriPrice != 0 {
		dAtA[i] = 0x31
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OriPrice))))
		i += 8
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Status))
	}
	if m.Network != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Network))
	}
	if len(m.PreviewUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.PreviewUrl)))
		i += copy(dAtA[i:], m.PreviewUrl)
	}
	if len(m.PackageName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.PackageName)))
		i += copy(dAtA[i:], m.PackageName)
	}
	if m.CampaignType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.CampaignType))
	}
	if m.CType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.CType))
	}
	if len(m.AppSize) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.AppSize)))
		i += copy(dAtA[i:], m.AppSize)
	}
	if m.Tag != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Tag))
	}
	if m.AdSourceId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.AdSourceId))
	}
	if m.PublisherId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.PublisherId))
	}
	if m.PreClickCacheTime != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.PreClickCacheTime))
	}
	if m.FrequencyCap != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.FrequencyCap))
	}
	if len(m.DirectPackageName) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.DirectPackageName)))
		i += copy(dAtA[i:], m.DirectPackageName)
	}
	if len(m.SdkPackageName) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.SdkPackageName)))
		i += copy(dAtA[i:], m.SdkPackageName)
	}
	if m.JumpType != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.JumpType))
	}
	if m.VbaConnecting != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.VbaConnecting))
	}
	if len(m.VbaTrackingLink) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.VbaTrackingLink)))
		i += copy(dAtA[i:], m.VbaTrackingLink)
	}
	if m.RetargetingDevice != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.RetargetingDevice))
	}
	if m.SendDeviceidRate != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.SendDeviceidRate))
	}
	if m.BelongType != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.BelongType))
	}
	if m.OpenType != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.OpenType))
	}
	if m.IsCampaignCreative != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.IsCampaignCreative))
	}
	if m.CostType != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.CostType))
	}
	if m.Source != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Source))
	}
	if m.ChnId != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.ChnId))
	}
	if len(m.ThirdParty) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.ThirdParty)))
		i += copy(dAtA[i:], m.ThirdParty)
	}
	if len(m.AdUrlList) > 0 {
		for _, s := range m.AdUrlList {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SubCategoryName) > 0 {
		for _, s := range m.SubCategoryName {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.JumpTypeConfig) > 0 {
		for k, _ := range m.JumpTypeConfig {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			v := m.JumpTypeConfig[k]
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + 1 + sovCampaign(uint64(v))
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(v))
		}
	}
	if len(m.BlackSubIdListV2) > 0 {
		for k, _ := range m.BlackSubIdListV2 {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x2
			i++
			v := m.BlackSubIdListV2[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCampaign(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + msgSize
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCampaign(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.AdvImp) > 0 {
		for _, msg := range m.AdvImp {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LoopBack != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.LoopBack.Size()))
		n2, err := m.LoopBack.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.AppPostList != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.AppPostList.Size()))
		n3, err := m.AppPostList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ConfigVBA != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.ConfigVBA.Size()))
		n4, err := m.ConfigVBA.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Tcqf != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Tcqf.Size()))
		n5, err := m.Tcqf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.BtV4 != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.BtV4.Size()))
		n6, err := m.BtV4.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.EndCard) > 0 {
		for k, _ := range m.EndCard {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			v := m.EndCard[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCampaign(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + msgSize
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCampaign(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	return i, nil
}

func (m *MapValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MapValue) > 0 {
		for k, _ := range m.MapValue {
			dAtA[i] = 0xa
			i++
			v := m.MapValue[k]
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + 1 + len(v) + sovCampaign(uint64(len(v)))
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *AdvImp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvImp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Sec))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *LoopBack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopBack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Domain) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.Domain)))
		i += copy(dAtA[i:], m.Domain)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Rate != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Rate))
	}
	return i, nil
}

func (m *AppPostList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppPostList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Include) > 0 {
		for _, s := range m.Include {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Exclude) > 0 {
		for _, s := range m.Exclude {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *EndCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Urls) > 0 {
		for _, msg := range m.Urls {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Status))
	}
	if m.Orientation != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Orientation))
	}
	if len(m.VideoTemplateUrl) > 0 {
		for _, msg := range m.VideoTemplateUrl {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EndcardProtocal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.EndcardProtocal))
	}
	if len(m.EndcardRate) > 0 {
		for k, _ := range m.EndcardRate {
			dAtA[i] = 0x32
			i++
			v := m.EndcardRate[k]
			mapSize := 1 + sovCampaign(uint64(k)) + 1 + sovCampaign(uint64(v))
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *VideoTemplateUrlItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoTemplateUrlItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Id))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.UrlZip) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.UrlZip)))
		i += copy(dAtA[i:], m.UrlZip)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Weight))
	}
	if len(m.PausedUrl) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.PausedUrl)))
		i += copy(dAtA[i:], m.PausedUrl)
	}
	if len(m.PausedUrlZip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.PausedUrlZip)))
		i += copy(dAtA[i:], m.PausedUrlZip)
	}
	return i, nil
}

func (m *EndCardUrls) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndCardUrls) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Id))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Weight))
	}
	if len(m.UrlV2) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.UrlV2)))
		i += copy(dAtA[i:], m.UrlV2)
	}
	return i, nil
}

func (m *ConfigVBA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigVBA) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseVBA != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.UseVBA))
	}
	if m.FrequencyCap != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.FrequencyCap))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *TCQF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TCQF) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubIds) > 0 {
		for k, _ := range m.SubIds {
			dAtA[i] = 0xa
			i++
			v := m.SubIds[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCampaign(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + msgSize
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCampaign(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *BtV4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BtV4) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubIds) > 0 {
		for k, _ := range m.SubIds {
			dAtA[i] = 0xa
			i++
			v := m.SubIds[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCampaign(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + msgSize
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCampaign(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	if len(m.BtClass) > 0 {
		for k, _ := range m.BtClass {
			dAtA[i] = 0x12
			i++
			v := m.BtClass[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCampaign(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + msgSize
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCampaign(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *BtClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BtClass) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Percent != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Percent))))
		i += 8
	}
	if m.CapMargin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.CapMargin))
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *SubInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Rate))
	}
	if len(m.PackageName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.PackageName)))
		i += copy(dAtA[i:], m.PackageName)
	}
	if len(m.DspSubInfo) > 0 {
		for k, _ := range m.DspSubInfo {
			dAtA[i] = 0x1a
			i++
			v := m.DspSubInfo[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCampaign(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCampaign(uint64(len(k))) + msgSize
			i = encodeVarintCampaign(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCampaign(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCampaign(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	return i, nil
}

func (m *DspSubInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DspSubInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(m.Rate))
	}
	if len(m.PackageName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCampaign(dAtA, i, uint64(len(m.PackageName)))
		i += copy(dAtA[i:], m.PackageName)
	}
	return i, nil
}

func encodeVarintCampaign(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Campaign) Size() (n int) {
	var l int
	_ = l
	if m.CampaignId != 0 {
		n += 1 + sovCampaign(uint64(m.CampaignId))
	}
	if m.AdvertiserId != 0 {
		n += 1 + sovCampaign(uint64(m.AdvertiserId))
	}
	l = len(m.TrackingUrl)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	l = len(m.DirectUrl)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.OriPrice != 0 {
		n += 9
	}
	if m.Status != 0 {
		n += 1 + sovCampaign(uint64(m.Status))
	}
	if m.Network != 0 {
		n += 1 + sovCampaign(uint64(m.Network))
	}
	l = len(m.PreviewUrl)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	l = len(m.PackageName)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if m.CampaignType != 0 {
		n += 1 + sovCampaign(uint64(m.CampaignType))
	}
	if m.CType != 0 {
		n += 1 + sovCampaign(uint64(m.CType))
	}
	l = len(m.AppSize)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovCampaign(uint64(m.Tag))
	}
	if m.AdSourceId != 0 {
		n += 1 + sovCampaign(uint64(m.AdSourceId))
	}
	if m.PublisherId != 0 {
		n += 2 + sovCampaign(uint64(m.PublisherId))
	}
	if m.PreClickCacheTime != 0 {
		n += 2 + sovCampaign(uint64(m.PreClickCacheTime))
	}
	if m.FrequencyCap != 0 {
		n += 2 + sovCampaign(uint64(m.FrequencyCap))
	}
	l = len(m.DirectPackageName)
	if l > 0 {
		n += 2 + l + sovCampaign(uint64(l))
	}
	l = len(m.SdkPackageName)
	if l > 0 {
		n += 2 + l + sovCampaign(uint64(l))
	}
	if m.JumpType != 0 {
		n += 2 + sovCampaign(uint64(m.JumpType))
	}
	if m.VbaConnecting != 0 {
		n += 2 + sovCampaign(uint64(m.VbaConnecting))
	}
	l = len(m.VbaTrackingLink)
	if l > 0 {
		n += 2 + l + sovCampaign(uint64(l))
	}
	if m.RetargetingDevice != 0 {
		n += 2 + sovCampaign(uint64(m.RetargetingDevice))
	}
	if m.SendDeviceidRate != 0 {
		n += 2 + sovCampaign(uint64(m.SendDeviceidRate))
	}
	if m.BelongType != 0 {
		n += 2 + sovCampaign(uint64(m.BelongType))
	}
	if m.OpenType != 0 {
		n += 2 + sovCampaign(uint64(m.OpenType))
	}
	if m.IsCampaignCreative != 0 {
		n += 2 + sovCampaign(uint64(m.IsCampaignCreative))
	}
	if m.CostType != 0 {
		n += 2 + sovCampaign(uint64(m.CostType))
	}
	if m.Source != 0 {
		n += 2 + sovCampaign(uint64(m.Source))
	}
	if m.ChnId != 0 {
		n += 2 + sovCampaign(uint64(m.ChnId))
	}
	l = len(m.ThirdParty)
	if l > 0 {
		n += 2 + l + sovCampaign(uint64(l))
	}
	if len(m.AdUrlList) > 0 {
		for _, s := range m.AdUrlList {
			l = len(s)
			n += 2 + l + sovCampaign(uint64(l))
		}
	}
	if len(m.SubCategoryName) > 0 {
		for _, s := range m.SubCategoryName {
			l = len(s)
			n += 2 + l + sovCampaign(uint64(l))
		}
	}
	if len(m.JumpTypeConfig) > 0 {
		for k, v := range m.JumpTypeConfig {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + 1 + sovCampaign(uint64(v))
			n += mapEntrySize + 2 + sovCampaign(uint64(mapEntrySize))
		}
	}
	if len(m.BlackSubIdListV2) > 0 {
		for k, v := range m.BlackSubIdListV2 {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCampaign(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCampaign(uint64(mapEntrySize))
		}
	}
	if len(m.AdvImp) > 0 {
		for _, e := range m.AdvImp {
			l = e.Size()
			n += 2 + l + sovCampaign(uint64(l))
		}
	}
	if m.LoopBack != nil {
		l = m.LoopBack.Size()
		n += 2 + l + sovCampaign(uint64(l))
	}
	if m.AppPostList != nil {
		l = m.AppPostList.Size()
		n += 2 + l + sovCampaign(uint64(l))
	}
	if m.ConfigVBA != nil {
		l = m.ConfigVBA.Size()
		n += 2 + l + sovCampaign(uint64(l))
	}
	if m.Tcqf != nil {
		l = m.Tcqf.Size()
		n += 2 + l + sovCampaign(uint64(l))
	}
	if m.BtV4 != nil {
		l = m.BtV4.Size()
		n += 2 + l + sovCampaign(uint64(l))
	}
	if len(m.EndCard) > 0 {
		for k, v := range m.EndCard {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCampaign(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCampaign(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MapValue) Size() (n int) {
	var l int
	_ = l
	if len(m.MapValue) > 0 {
		for k, v := range m.MapValue {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + 1 + len(v) + sovCampaign(uint64(len(v)))
			n += mapEntrySize + 1 + sovCampaign(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AdvImp) Size() (n int) {
	var l int
	_ = l
	if m.Sec != 0 {
		n += 1 + sovCampaign(uint64(m.Sec))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	return n
}

func (m *LoopBack) Size() (n int) {
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if m.Rate != 0 {
		n += 1 + sovCampaign(uint64(m.Rate))
	}
	return n
}

func (m *AppPostList) Size() (n int) {
	var l int
	_ = l
	if len(m.Include) > 0 {
		for _, s := range m.Include {
			l = len(s)
			n += 1 + l + sovCampaign(uint64(l))
		}
	}
	if len(m.Exclude) > 0 {
		for _, s := range m.Exclude {
			l = len(s)
			n += 1 + l + sovCampaign(uint64(l))
		}
	}
	return n
}

func (m *EndCard) Size() (n int) {
	var l int
	_ = l
	if len(m.Urls) > 0 {
		for _, e := range m.Urls {
			l = e.Size()
			n += 1 + l + sovCampaign(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovCampaign(uint64(m.Status))
	}
	if m.Orientation != 0 {
		n += 1 + sovCampaign(uint64(m.Orientation))
	}
	if len(m.VideoTemplateUrl) > 0 {
		for _, e := range m.VideoTemplateUrl {
			l = e.Size()
			n += 1 + l + sovCampaign(uint64(l))
		}
	}
	if m.EndcardProtocal != 0 {
		n += 1 + sovCampaign(uint64(m.EndcardProtocal))
	}
	if len(m.EndcardRate) > 0 {
		for k, v := range m.EndcardRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovCampaign(uint64(k)) + 1 + sovCampaign(uint64(v))
			n += mapEntrySize + 1 + sovCampaign(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VideoTemplateUrlItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCampaign(uint64(m.Id))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	l = len(m.UrlZip)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovCampaign(uint64(m.Weight))
	}
	l = len(m.PausedUrl)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	l = len(m.PausedUrlZip)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	return n
}

func (m *EndCardUrls) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCampaign(uint64(m.Id))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovCampaign(uint64(m.Weight))
	}
	l = len(m.UrlV2)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	return n
}

func (m *ConfigVBA) Size() (n int) {
	var l int
	_ = l
	if m.UseVBA != 0 {
		n += 1 + sovCampaign(uint64(m.UseVBA))
	}
	if m.FrequencyCap != 0 {
		n += 1 + sovCampaign(uint64(m.FrequencyCap))
	}
	if m.Status != 0 {
		n += 1 + sovCampaign(uint64(m.Status))
	}
	return n
}

func (m *TCQF) Size() (n int) {
	var l int
	_ = l
	if len(m.SubIds) > 0 {
		for k, v := range m.SubIds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCampaign(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCampaign(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BtV4) Size() (n int) {
	var l int
	_ = l
	if len(m.SubIds) > 0 {
		for k, v := range m.SubIds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCampaign(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCampaign(uint64(mapEntrySize))
		}
	}
	if len(m.BtClass) > 0 {
		for k, v := range m.BtClass {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCampaign(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCampaign(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BtClass) Size() (n int) {
	var l int
	_ = l
	if m.Percent != 0 {
		n += 9
	}
	if m.CapMargin != 0 {
		n += 1 + sovCampaign(uint64(m.CapMargin))
	}
	if m.Status != 0 {
		n += 1 + sovCampaign(uint64(m.Status))
	}
	return n
}

func (m *SubInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovCampaign(uint64(m.Rate))
	}
	l = len(m.PackageName)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	if len(m.DspSubInfo) > 0 {
		for k, v := range m.DspSubInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCampaign(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCampaign(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCampaign(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DspSubInfo) Size() (n int) {
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovCampaign(uint64(m.Rate))
	}
	l = len(m.PackageName)
	if l > 0 {
		n += 1 + l + sovCampaign(uint64(l))
	}
	return n
}

func sovCampaign(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCampaign(x uint64) (n int) {
	return sovCampaign(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Campaign) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Campaign: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Campaign: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignId", wireType)
			}
			m.CampaignId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CampaignId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiserId", wireType)
			}
			m.AdvertiserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdvertiserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackingUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrackingUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OriPrice = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			m.Network = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Network |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignType", wireType)
			}
			m.CampaignType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CampaignType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CType", wireType)
			}
			m.CType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdSourceId", wireType)
			}
			m.AdSourceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdSourceId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherId", wireType)
			}
			m.PublisherId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PublisherId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreClickCacheTime", wireType)
			}
			m.PreClickCacheTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreClickCacheTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyCap", wireType)
			}
			m.FrequencyCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyCap |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkPackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SdkPackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpType", wireType)
			}
			m.JumpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JumpType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VbaConnecting", wireType)
			}
			m.VbaConnecting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VbaConnecting |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VbaTrackingLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VbaTrackingLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetargetingDevice", wireType)
			}
			m.RetargetingDevice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetargetingDevice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendDeviceidRate", wireType)
			}
			m.SendDeviceidRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendDeviceidRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelongType", wireType)
			}
			m.BelongType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BelongType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenType", wireType)
			}
			m.OpenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCampaignCreative", wireType)
			}
			m.IsCampaignCreative = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCampaignCreative |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostType", wireType)
			}
			m.CostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChnId", wireType)
			}
			m.ChnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChnId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThirdParty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThirdParty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdUrlList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdUrlList = append(m.AdUrlList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCategoryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCategoryName = append(m.SubCategoryName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JumpTypeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JumpTypeConfig == nil {
				m.JumpTypeConfig = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JumpTypeConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlackSubIdListV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlackSubIdListV2 == nil {
				m.BlackSubIdListV2 = make(map[string]*MapValue)
			}
			var mapkey string
			var mapvalue *MapValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MapValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BlackSubIdListV2[mapkey] = mapvalue
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvImp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvImp = append(m.AdvImp, &AdvImp{})
			if err := m.AdvImp[len(m.AdvImp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopBack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LoopBack == nil {
				m.LoopBack = &LoopBack{}
			}
			if err := m.LoopBack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPostList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppPostList == nil {
				m.AppPostList = &AppPostList{}
			}
			if err := m.AppPostList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigVBA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigVBA == nil {
				m.ConfigVBA = &ConfigVBA{}
			}
			if err := m.ConfigVBA.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcqf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tcqf == nil {
				m.Tcqf = &TCQF{}
			}
			if err := m.Tcqf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtV4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BtV4 == nil {
				m.BtV4 = &BtV4{}
			}
			if err := m.BtV4.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndCard == nil {
				m.EndCard = make(map[string]*EndCard)
			}
			var mapkey string
			var mapvalue *EndCard
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EndCard{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndCard[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapValue == nil {
				m.MapValue = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapValue[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvImp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvImp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvImp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sec", wireType)
			}
			m.Sec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopBack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopBack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopBack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppPostList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppPostList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppPostList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = append(m.Include, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Urls = append(m.Urls, &EndCardUrls{})
			if err := m.Urls[len(m.Urls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orientation", wireType)
			}
			m.Orientation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Orientation |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoTemplateUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoTemplateUrl = append(m.VideoTemplateUrl, &VideoTemplateUrlItem{})
			if err := m.VideoTemplateUrl[len(m.VideoTemplateUrl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndcardProtocal", wireType)
			}
			m.EndcardProtocal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndcardProtocal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndcardRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndcardRate == nil {
				m.EndcardRate = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EndcardRate[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoTemplateUrlItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoTemplateUrlItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoTemplateUrlItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlZip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlZip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PausedUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedUrlZip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PausedUrlZip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndCardUrls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndCardUrls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndCardUrls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlV2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlV2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigVBA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigVBA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigVBA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVBA", wireType)
			}
			m.UseVBA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseVBA |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyCap", wireType)
			}
			m.FrequencyCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyCap |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TCQF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCQF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCQF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubIds == nil {
				m.SubIds = make(map[string]*SubInfo)
			}
			var mapkey string
			var mapvalue *SubInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SubInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubIds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BtV4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BtV4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BtV4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubIds == nil {
				m.SubIds = make(map[string]*SubInfo)
			}
			var mapkey string
			var mapvalue *SubInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SubInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubIds[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BtClass == nil {
				m.BtClass = make(map[string]*BtClass)
			}
			var mapkey string
			var mapvalue *BtClass
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BtClass{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BtClass[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BtClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BtClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BtClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Percent = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapMargin", wireType)
			}
			m.CapMargin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapMargin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DspSubInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DspSubInfo == nil {
				m.DspSubInfo = make(map[string]*DspSubInfo)
			}
			var mapkey string
			var mapvalue *DspSubInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCampaign
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCampaign
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCampaign
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DspSubInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCampaign(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCampaign
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DspSubInfo[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DspSubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DspSubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DspSubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCampaign
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCampaign(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCampaign
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCampaign(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCampaign
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCampaign
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCampaign
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCampaign
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCampaign(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCampaign = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCampaign   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("campaign.proto", fileDescriptorCampaign) }

var fileDescriptorCampaign = []byte{
	// 1427 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6f, 0x1b, 0x45,
	0x1b, 0x7f, 0xd7, 0x8e, 0x1d, 0xfb, 0x71, 0x9b, 0xba, 0xd3, 0xa4, 0xef, 0xbc, 0x6e, 0xdf, 0xd4,
	0x35, 0xa5, 0x75, 0x4b, 0x65, 0x89, 0x50, 0xc4, 0xa7, 0x90, 0x12, 0xb7, 0x48, 0xa9, 0xd2, 0x2a,
	0x6c, 0x52, 0x23, 0x90, 0x00, 0x8d, 0x77, 0x27, 0xce, 0xe2, 0xf5, 0xee, 0x76, 0x76, 0xd6, 0x25,
	0xdc, 0x91, 0x38, 0x71, 0xe6, 0x6f, 0xe0, 0xcf, 0xe0, 0xc4, 0x91, 0x1b, 0x57, 0x54, 0x6e, 0xfc,
	0x15, 0x68, 0x9e, 0x99, 0xf5, 0x8e, 0x3f, 0xa0, 0x14, 0x71, 0xf2, 0x3c, 0xbf, 0xe7, 0xfb, 0x63,
	0x9e, 0x1d, 0xc3, 0x86, 0xc7, 0x26, 0x09, 0x0b, 0x46, 0x51, 0x2f, 0x11, 0xb1, 0x8c, 0x49, 0x0d,
	0x7f, 0x86, 0xd9, 0x49, 0xe7, 0xc7, 0x0d, 0xa8, 0xf5, 0x0d, 0x93, 0x6c, 0x03, 0xe4, 0x82, 0xfb,
	0x3e, 0x75, 0xda, 0x4e, 0xb7, 0xec, 0x5a, 0x08, 0xe9, 0xc0, 0x39, 0xe6, 0x4f, 0xb9, 0x90, 0x41,
	0xca, 0xc5, 0xbe, 0x4f, 0x4b, 0x6d, 0xa7, 0x5b, 0x71, 0xe7, 0x30, 0xd2, 0x86, 0x86, 0x14, 0xcc,
	0x1b, 0x07, 0xd1, 0xe8, 0x89, 0x08, 0x69, 0xb9, 0xed, 0x74, 0xeb, 0xae, 0x0d, 0x91, 0xab, 0x50,
	0xf7, 0x03, 0xc1, 0x3d, 0xa9, 0xf8, 0x6b, 0xc8, 0x2f, 0x00, 0xb2, 0x09, 0x95, 0x44, 0x04, 0x1e,
	0xa7, 0x95, 0xb6, 0xd3, 0x75, 0x5c, 0x4d, 0x90, 0x16, 0xd4, 0x62, 0x11, 0x1c, 0x22, 0xa3, 0x8a,
	0x8c, 0x19, 0x4d, 0x2e, 0x43, 0x35, 0x95, 0x4c, 0x66, 0x29, 0x5d, 0xc7, 0x78, 0x0c, 0x45, 0x28,
	0xac, 0x47, 0x5c, 0x3e, 0x8b, 0xc5, 0x98, 0xd6, 0x90, 0x91, 0x93, 0x2a, 0xcf, 0x44, 0xf0, 0x69,
	0xc0, 0x9f, 0xa9, 0x10, 0xea, 0x18, 0x82, 0x85, 0xa8, 0x1c, 0x12, 0xe6, 0x8d, 0xd9, 0x88, 0x3f,
	0x66, 0x13, 0x4e, 0x41, 0xe7, 0x60, 0x41, 0xaa, 0x12, 0x79, 0x5d, 0x8e, 0xcf, 0x12, 0x4e, 0x1b,
	0xba, 0x12, 0x36, 0xa6, 0x32, 0xf1, 0x90, 0x79, 0x0e, 0x99, 0x9a, 0x50, 0x51, 0xb1, 0x24, 0x39,
	0x0a, 0xbe, 0xe6, 0xf4, 0x3c, 0xda, 0xcd, 0x49, 0xd2, 0x84, 0xb2, 0x64, 0x23, 0xba, 0x81, 0xd2,
	0xea, 0xa8, 0xe2, 0x64, 0xfe, 0x51, 0x9c, 0x09, 0x8f, 0xef, 0xfb, 0xf4, 0x02, 0x32, 0x2c, 0x04,
	0xe3, 0xcc, 0x86, 0x61, 0x90, 0x9e, 0x62, 0x3b, 0x9a, 0xd8, 0x30, 0x1b, 0x22, 0x77, 0xe1, 0x62,
	0x22, 0x78, 0x3f, 0x0c, 0xbc, 0x71, 0x9f, 0x79, 0xa7, 0xfc, 0x38, 0x98, 0x70, 0x7a, 0x11, 0x0d,
	0x2d, 0x33, 0x54, 0x56, 0x27, 0x82, 0x3f, 0xcd, 0x78, 0xe4, 0x9d, 0xf5, 0x59, 0x42, 0x89, 0xce,
	0xca, 0xc6, 0x94, 0x45, 0xdd, 0xac, 0x43, 0xab, 0x42, 0x97, 0x30, 0x93, 0x65, 0x06, 0xb9, 0x09,
	0x1b, 0xa9, 0x3f, 0xb6, 0x45, 0x37, 0x51, 0x74, 0x01, 0x55, 0xfd, 0xfd, 0x32, 0x9b, 0x24, 0x58,
	0xae, 0x2d, 0xf4, 0x3a, 0xa3, 0xc9, 0x0d, 0x38, 0x3f, 0x1d, 0xb2, 0x7e, 0x1c, 0x45, 0xdc, 0x93,
	0x41, 0x34, 0xa2, 0x97, 0x51, 0x60, 0x1e, 0x24, 0x5d, 0xb8, 0x30, 0x1d, 0xb2, 0x63, 0x33, 0x67,
	0x07, 0x41, 0x34, 0xa6, 0xff, 0x45, 0x57, 0x8b, 0xb0, 0xca, 0x40, 0x70, 0xc9, 0xc4, 0x88, 0x2b,
	0xc5, 0xfb, 0x7c, 0xaa, 0x86, 0x8a, 0xea, 0x9a, 0x2c, 0x31, 0xc8, 0x1d, 0x68, 0xa6, 0x3c, 0xf2,
	0x35, 0x15, 0xf8, 0x2e, 0x93, 0x9c, 0xfe, 0x0f, 0x85, 0x97, 0x70, 0xd5, 0xaf, 0x21, 0x0f, 0xe3,
	0x68, 0x84, 0x79, 0xb4, 0x74, 0xbf, 0x0a, 0x04, 0xa7, 0x38, 0xe1, 0x7a, 0x62, 0xae, 0xe8, 0x2c,
	0x73, 0x9a, 0xf4, 0x80, 0x04, 0x69, 0x7e, 0x13, 0xfb, 0x82, 0x33, 0x19, 0x4c, 0x39, 0xbd, 0x8a,
	0x52, 0x2b, 0x38, 0xca, 0x96, 0x17, 0xa7, 0x12, 0x6d, 0xfd, 0x5f, 0xdb, 0xca, 0x69, 0xbc, 0x11,
	0x38, 0x23, 0x74, 0xdb, 0xdc, 0x08, 0xa4, 0x70, 0x22, 0x4f, 0xd5, 0xd5, 0xbe, 0x66, 0x26, 0x52,
	0x11, 0x2a, 0x6a, 0x79, 0x1a, 0x08, 0xff, 0x90, 0x09, 0x79, 0x46, 0xdb, 0xfa, 0x36, 0x14, 0x88,
	0xba, 0xaf, 0xcc, 0x7f, 0x22, 0xc2, 0x83, 0x20, 0x95, 0xf4, 0x7a, 0xbb, 0xac, 0xee, 0xeb, 0x0c,
	0x50, 0x75, 0x4f, 0xb3, 0x61, 0x9f, 0x49, 0x3e, 0x8a, 0xc5, 0x19, 0xb6, 0xb8, 0x83, 0x32, 0x8b,
	0x30, 0x79, 0x0c, 0x1b, 0x79, 0x4f, 0xfb, 0x71, 0x74, 0x12, 0x8c, 0xe8, 0x2b, 0xed, 0x72, 0xb7,
	0xb1, 0x73, 0xb3, 0x97, 0x6f, 0xa3, 0x5e, 0x9e, 0x65, 0xef, 0xe1, 0x9c, 0xe0, 0x83, 0x48, 0x8a,
	0x33, 0x77, 0x41, 0x9b, 0x1c, 0x43, 0x73, 0x18, 0x32, 0x6f, 0x7c, 0x94, 0x0d, 0xf7, 0x7d, 0x15,
	0xcb, 0x60, 0x87, 0xde, 0x40, 0x8b, 0xdd, 0x15, 0x16, 0xf7, 0x16, 0x44, 0xb5, 0xcd, 0x25, 0x0b,
	0xa4, 0x0b, 0x55, 0xe6, 0x4f, 0xf7, 0x27, 0x09, 0x7d, 0x15, 0x6d, 0x35, 0x0b, 0x5b, 0xbb, 0x88,
	0xbb, 0x86, 0x4f, 0x7a, 0x50, 0x0b, 0xe3, 0x38, 0xd9, 0x63, 0xde, 0x98, 0xde, 0x6c, 0x3b, 0xdd,
	0xc6, 0x0e, 0x29, 0x64, 0x0f, 0x0c, 0xc7, 0x9d, 0xc9, 0x90, 0xb7, 0xa0, 0xc1, 0x92, 0xe4, 0x30,
	0x4e, 0x25, 0x56, 0xf2, 0x16, 0xaa, 0x6c, 0x59, 0xe6, 0x0b, 0xa6, 0x6b, 0x4b, 0x92, 0xd7, 0xa1,
	0xee, 0x61, 0xca, 0x83, 0xbd, 0x5d, 0xda, 0x45, 0xb5, 0x4b, 0x56, 0x86, 0x39, 0xcb, 0x2d, 0xa4,
	0x48, 0x07, 0xd6, 0xa4, 0xf7, 0xf4, 0x84, 0xde, 0x46, 0xe9, 0x8d, 0x42, 0xfa, 0xb8, 0xff, 0xd1,
	0x87, 0x2e, 0xf2, 0x94, 0xcc, 0x50, 0x0e, 0xee, 0xd1, 0x3b, 0x8b, 0x32, 0x7b, 0x72, 0x70, 0xcf,
	0x45, 0x1e, 0x79, 0x07, 0xd6, 0x79, 0xe4, 0xf7, 0x99, 0xf0, 0xe9, 0x6b, 0x58, 0x8e, 0x6b, 0x2b,
	0x4a, 0xfb, 0x40, 0x4b, 0xe8, 0x8a, 0xe6, 0xf2, 0xad, 0x5d, 0xb8, 0xb4, 0xa2, 0x8b, 0x6a, 0xcb,
	0x8d, 0xf9, 0x19, 0x7e, 0x5c, 0xea, 0xae, 0x3a, 0xaa, 0xa9, 0x9c, 0xb2, 0x30, 0xe3, 0xe6, 0x73,
	0xa2, 0x89, 0x77, 0x4b, 0x6f, 0x3b, 0xad, 0x8f, 0x61, 0x6b, 0x65, 0xdb, 0x56, 0x18, 0xe9, 0xda,
	0x46, 0xe6, 0x3a, 0xf1, 0x88, 0x25, 0x03, 0xc5, 0xb1, 0x0d, 0x3f, 0x82, 0x73, 0x76, 0xd0, 0x2b,
	0xec, 0xdd, 0x9a, 0xb7, 0x77, 0xb1, 0xb0, 0x67, 0x14, 0x2d, 0x73, 0x9d, 0x6f, 0x1c, 0xa8, 0xe5,
	0x6e, 0xc8, 0xfb, 0x50, 0x9b, 0x98, 0x33, 0x75, 0xb0, 0x66, 0xed, 0xe5, 0x60, 0x66, 0x07, 0x5d,
	0xb4, 0x99, 0x46, 0xeb, 0x3d, 0x38, 0x3f, 0xc7, 0x7a, 0x51, 0xbd, 0xea, 0x76, 0x1c, 0x77, 0xa1,
	0xaa, 0x67, 0x54, 0x69, 0xa5, 0xdc, 0x43, 0xad, 0x8a, 0xab, 0x8e, 0x0a, 0xc9, 0x44, 0x68, 0x74,
	0xd4, 0xb1, 0xf3, 0x39, 0xd4, 0xf2, 0x29, 0x55, 0x1b, 0xc3, 0x8f, 0x27, 0x2c, 0x88, 0x8c, 0x23,
	0x43, 0xe5, 0xde, 0x4b, 0x2b, 0xbc, 0x97, 0x2d, 0xef, 0x84, 0xc0, 0x9a, 0x50, 0x9b, 0x71, 0x0d,
	0x1d, 0xe2, 0xb9, 0xb3, 0x0b, 0x0d, 0x6b, 0xa4, 0xd5, 0x87, 0x2f, 0x88, 0xbc, 0x30, 0xf3, 0x75,
	0x59, 0xea, 0x6e, 0x4e, 0x2a, 0x0e, 0xff, 0x4a, 0x73, 0x4a, 0x9a, 0x63, 0xc8, 0xce, 0xef, 0x25,
	0x58, 0x37, 0xf5, 0x26, 0xb7, 0x61, 0x2d, 0x13, 0x61, 0x6a, 0x6a, 0xba, 0xb5, 0xd4, 0x90, 0x27,
	0x22, 0x4c, 0x5d, 0x14, 0xb1, 0x5e, 0x04, 0xa5, 0xb9, 0x17, 0x41, 0x1b, 0x1a, 0xb1, 0x08, 0x78,
	0x24, 0x99, 0x0c, 0xe2, 0x08, 0x33, 0xa8, 0xb8, 0x36, 0x44, 0x1e, 0x42, 0x73, 0x1a, 0xf8, 0x3c,
	0x3e, 0xe6, 0x93, 0x24, 0x64, 0x92, 0xeb, 0x27, 0x8a, 0x72, 0xb8, 0x5d, 0x38, 0x1c, 0x2c, 0x48,
	0xec, 0x4b, 0x3e, 0x71, 0x97, 0xf4, 0xd4, 0x66, 0xe4, 0x91, 0xef, 0x31, 0xe1, 0x1f, 0x2a, 0x4d,
	0x8f, 0x85, 0xf8, 0xa6, 0xa9, 0xb8, 0x8b, 0x30, 0xb9, 0x0f, 0x0d, 0x03, 0xe1, 0xe7, 0xa5, 0x8a,
	0x0e, 0x3b, 0x4b, 0x19, 0xaa, 0xdf, 0x5c, 0x48, 0xcf, 0x8d, 0xad, 0xd6, 0xfa, 0x00, 0x9a, 0x8b,
	0x02, 0xf6, 0xf4, 0x54, 0x5e, 0x70, 0xdb, 0x3a, 0x3f, 0x38, 0xb0, 0xb9, 0x2a, 0x35, 0xb2, 0x01,
	0xa5, 0xc0, 0x37, 0x36, 0x4a, 0x81, 0xbf, 0x3c, 0x4a, 0xaa, 0xe0, 0x99, 0x08, 0x3f, 0x0d, 0x12,
	0x33, 0x15, 0x86, 0x52, 0xf8, 0x33, 0x1e, 0x8c, 0x4e, 0xa5, 0x19, 0x0c, 0x43, 0xa9, 0x4f, 0x4a,
	0xc2, 0xb2, 0x94, 0xab, 0xa6, 0x61, 0x51, 0xea, 0x6e, 0x01, 0xa8, 0x67, 0xc8, 0x8c, 0x50, 0x36,
	0xab, 0x28, 0x30, 0x87, 0x75, 0x3e, 0x83, 0x86, 0xd5, 0xf7, 0xbf, 0x17, 0xa2, 0x09, 0xa5, 0x3c,
	0x17, 0xca, 0x26, 0x54, 0x32, 0x11, 0x0e, 0x76, 0xcc, 0x4b, 0x54, 0x13, 0x9d, 0x2f, 0xa0, 0x3e,
	0xdb, 0xab, 0x98, 0x5d, 0xca, 0xd5, 0xf2, 0xd5, 0x0e, 0x0c, 0xb5, 0xf4, 0x5c, 0x2a, 0xad, 0x78,
	0x2e, 0x15, 0xa3, 0x58, 0xb6, 0x47, 0xb1, 0xf3, 0xad, 0x03, 0x6b, 0x6a, 0x17, 0x93, 0x1d, 0xa8,
	0xa6, 0x6a, 0xbd, 0xe5, 0x83, 0xdd, 0x9a, 0xdf, 0xd5, 0x3d, 0xdc, 0x7d, 0xa9, 0x6e, 0xb7, 0x91,
	0x6c, 0x1d, 0x40, 0xc3, 0x82, 0x5f, 0x6a, 0x7b, 0x29, 0xbd, 0xe8, 0x24, 0xb6, 0xfb, 0xfe, 0x5d,
	0x09, 0xd6, 0xd4, 0xca, 0xff, 0xab, 0x50, 0x14, 0x7f, 0x55, 0x28, 0xe4, 0x4d, 0x58, 0x1f, 0xca,
	0x7e, 0xc8, 0xd2, 0x14, 0xef, 0x6e, 0x63, 0xe7, 0xca, 0x82, 0xd2, 0x9e, 0xe6, 0x9a, 0x8f, 0x83,
	0x91, 0xfd, 0x77, 0x33, 0x50, 0xeb, 0xdc, 0x76, 0xf3, 0x52, 0xe6, 0x8c, 0xa2, 0x5d, 0x90, 0x4f,
	0x60, 0xdd, 0xa0, 0x6a, 0x35, 0x25, 0x5c, 0x78, 0x3c, 0x92, 0x68, 0xcd, 0x71, 0x73, 0x52, 0x8d,
	0xb0, 0xc7, 0x92, 0x47, 0x4c, 0x8c, 0x82, 0xc8, 0x74, 0xbe, 0x00, 0xfe, 0xb4, 0xed, 0xbf, 0x38,
	0xb0, 0x6e, 0x12, 0x98, 0xed, 0x4c, 0xa7, 0xd8, 0x99, 0x8b, 0xff, 0x3c, 0x4a, 0xcb, 0xff, 0x3c,
	0x76, 0x01, 0xfc, 0x34, 0x31, 0x36, 0x68, 0x19, 0x6b, 0x7e, 0x7d, 0xa9, 0x3a, 0xbd, 0xfb, 0x33,
	0x19, 0x5d, 0x79, 0x4b, 0xa9, 0x75, 0x04, 0x17, 0x16, 0xd8, 0x2b, 0x2a, 0x76, 0x67, 0xbe, 0x62,
	0x9b, 0x85, 0x8b, 0x42, 0xd7, 0x2e, 0xda, 0x1e, 0x40, 0xc1, 0xf8, 0x67, 0xb9, 0xed, 0x35, 0x7f,
	0x7a, 0xbe, 0xed, 0xfc, 0xfc, 0x7c, 0xdb, 0xf9, 0xf5, 0xf9, 0xb6, 0xf3, 0xfd, 0x6f, 0xdb, 0xff,
	0x19, 0x56, 0xd1, 0xeb, 0x1b, 0x7f, 0x04, 0x00, 0x00, 0xff, 0xff, 0x50, 0x30, 0x09, 0xea, 0xc1,
	0x0e, 0x00, 0x00,
}
